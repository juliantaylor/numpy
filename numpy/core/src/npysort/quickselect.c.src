/* -*- c -*- */

/*
 * 
 * The code is based on the quickselect from
 * Nicolas Devillard - 1998 public domain
 * http://ndevilla.free.fr/median/median/
 *
 * Quick select is usually the fastest, but the worst case scenario can
 * be quadratic complexcity.
 */


#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include <stdlib.h>
#include "npy_sort.h"
#include "npysort_common.h"

#define NOT_USED NPY_UNUSED(unused)


/*
 *****************************************************************************
 **                            NUMERIC SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #suff = bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble#
 * #type = npy_bool, npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int,
 *         npy_uint, npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_ushort, npy_float, npy_double, npy_longdouble, npy_cfloat,
 *         npy_cdouble, npy_clongdouble#
 */

int
quickselect_@suff@(@type@ *start, npy_intp num, npy_intp kth,
                   void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        const npy_intp mid = low + (high - low) / 2;
        npy_intp       ll = low + 1;
        npy_intp       hh = high;

        /* swap 3-median into low and low into mid*/
        if (@TYPE@_LT(start[high], start[mid]))
            @TYPE@_SWAP(start[high], start[mid]);
        if (@TYPE@_LT(start[high], start[low]))
            @TYPE@_SWAP(start[high], start[low]);
        if (@TYPE@_LT(start[low], start[mid]))
            @TYPE@_SWAP(start[low], start[mid]);
        @TYPE@_SWAP(start[mid], start[low + 1]);

        const @type@ v = start[low];
        for (;;) {
            do ll++; while (@TYPE@_LT(start[ll], v));
            do hh--; while (@TYPE@_LT(v, start[hh]));

            if (hh < ll)
                break;

            @TYPE@_SWAP(start[ll], start[hh])
        }

        @TYPE@_SWAP(start[low], start[hh])

        if (hh >= kth)
            high = hh - 1; 
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(start[high], start[low]))
            @TYPE@_SWAP(start[high], start[low]);

    return 0;
}


int
aquickselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    return aquicksort_@suff@(v, tosort, num, NULL);
}

/**end repeat**/


/*
 *****************************************************************************
 **                             STRING SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = STRING, UNICODE#
 * #suff = string, unicode#
 * #type = npy_char, npy_ucs4#
 */

int
quickselect_@suff@(@type@ *start, npy_intp num, PyArrayObject *arr)
{
    return quicksort_@suff@(start, num, arr);
}


int
aquickselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, PyArrayObject *arr)
{
    return aquicksort_@suff@(v, tosort, num, arr);
}

/**end repeat**/


/*
 *****************************************************************************
 **                             GENERIC SORT                                **
 *****************************************************************************
 */


/*
 * This sort has almost the same signature as libc qsort and is intended to
 * supply an error return for compatibility with the other generic sort
 * kinds.
 */
int
npy_quickselect(void *base, size_t num, size_t size, npy_comparator cmp)
{
    return npy_quicksort(base, num, size, cmp);
}
