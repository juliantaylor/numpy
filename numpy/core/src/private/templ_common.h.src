#ifndef __NPY_TYPED_COMMON_INC
#define __NPY_TYPED_COMMON_INC

/* utility functions that profit from templates */

#include "numpy/npy_common.h"
#include "templ_common.h"

/**begin repeat
 *  #name = int, uint, long, ulong,
 *          longlong, ulonglong, intp#
 *  #type = npy_int, npy_uint, npy_long, npy_ulong,
 *          npy_longlong, npy_ulonglong, npy_intp#
 *  #MAX = NPY_MAX_INT, NPY_MAX_UINT, NPY_MAX_LONG, NPY_MAX_ULONG,
 *         NPY_MAX_LONGLONG, NPY_MAX_ULONGLONG, NPY_MAX_INTP#
 */

/*
 * writes result of a * b into r
 * returns 1 if a * b overflowed else returns 0
 */
static NPY_INLINE int
npy_mul_with_overflow_@name@(@type@ * r, @type@ a, @type@ b)
{
#ifdef HAVE___BUILTIN_MUL_OVERFLOW
    return __builtin_mul_overflow(a, b, r);
#else
    const @type@ half_sz = (((@type@)1 << (sizeof(a) * 8 / 2)) - 1);

    *r = a * b;
    /*
     * avoid expensive division on common no overflow case
     */
    if (NPY_UNLIKELY((a | b) >= half_sz) &&
        a != 0 && b > @MAX@ / a) {
        return 1;
    }

    return 0;
#endif
}
/**end repeat**/

/*
 * Returns -1 and sets an exception if *index is an invalid index for
 * an array of size max_item, otherwise adjusts it in place to be
 * 0 <= *index < max_item, and returns 0.
 * 'axis' should be the array axis that is being indexed over, if known. If
 * unknown, use -1.
 * If _save is NULL it is assumed the GIL is taken
 * If _save is not NULL it is assumed the GIL is not taken and it
 * is acquired in the case of an error
 */
/**begin repeat
 * #type = npy_int8, npy_int16, npy_int32, npy_int64,
 *         npy_uint8, npy_uint16, npy_uint32, npy_uint64#
 * #signed = 1*4, 0*4#
 */
static NPY_INLINE int
check_and_adjust_index_@type@(@type@ *index, @type@ max_item, int axis,
                              PyThreadState * _save)
{
    /* Check that index is valid, taking into account negative indices */
    if (NPY_UNLIKELY((@signed@ && *index < -max_item) || (*index >= max_item))) {
        NPY_END_THREADS;
        /* Try to be as clear as possible about what went wrong. */
        if (axis >= 0) {
            PyErr_Format(PyExc_IndexError,
                         "index %"NPY_INTP_FMT" is out of bounds "
                         "for axis %d with size %"NPY_INTP_FMT,
                         (npy_intp)*index, axis, (npy_intp)max_item);
        } else {
            PyErr_Format(PyExc_IndexError,
                         "index %"NPY_INTP_FMT" is out of bounds "
                         "for size %"NPY_INTP_FMT,
                         (npy_intp)*index, (npy_intp)max_item);
        }
        return -1;
    }
    /* adjust negative indices */
    if (@signed@ && *index < 0) {
        *index += max_item;
    }
    return 0;
}

/**end repeat**/

static NPY_INLINE int
check_and_adjust_index(npy_intp *index, npy_intp max_item, int axis,
                       PyThreadState * _save)
{
#if NPY_SIZEOF_INTP == 8
        return check_and_adjust_index_npy_int64(index, max_item, axis, _save);
#else
        return check_and_adjust_index_npy_int32(index, max_item, axis, _save);
#endif
}

#endif
