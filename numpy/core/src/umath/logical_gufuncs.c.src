#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "Python.h"
#include "math.h"
#include "numpy/ndarraytypes.h"
#include "numpy/ufuncobject.h"
#include "numpy/npy_3kcompat.h"
#include "logical_gufuncs.h"


// define the basic real version similar to the macro for complex numbers
#define REQ(a,b) (a==b)
#define RNE(a,b) (a!=b)
#define RLT(a,b) (a<b)
#define RLE(a,b) (a<=b)
#define RGT(a,b) (a>b)
#define RGE(a,b) (a>=b)

/* -------------------------------------------------------------------------- */
/* define the inner loops  */

#define all_INNER_LOOP(OP, TYPE)                \
    *((npy_bool *)c_n) = NPY_TRUE;              \
    for (i = 0; i < I; i++){                    \
        a = *(TYPE *)a_i;                       \
        b = *(TYPE *)b_i;                       \
        if (OP(a,b)){                           \
            a_i += a_I;                         \
            b_i += b_I;                         \
        } else {                                \
            *((npy_bool *)c_n) = NPY_FALSE;     \
            break;                              \
        }                                       \
    }

#define any_INNER_LOOP(OP, TYPE)                \
    *((npy_bool *)c_n) = NPY_FALSE;             \
    for (i = 0; i < I; i++){                    \
        a = *(TYPE *)a_i;                       \
        b = *(TYPE *)b_i;                       \
        if (OP(a,b)){                           \
            *((npy_bool *)c_n) = NPY_TRUE;      \
            break;                              \
        } else {                                \
            a_i += a_I;                         \
            b_i += b_I;                         \
        }                                       \
    }

/* -------------------------------------------------------------------------- */
/* create the family of functions using a template  */

/**begin repeat
* #TYPE = byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,
*         double,longdouble,cfloat,cdouble,clongdouble#
* #OP_PREFIX = R,R,R,R,R,R,R,R,R,R,R,R,R,PyArray_C,PyArray_C,PyArray_C#
*/

/**begin repeat1
* #OP = EQ,NE,LT,LE,GT,GE#
* #OPNAME = equal,not_equal,less,less_equal,greater,greater_equal#
*/

/**begin repeat2
* #ALL_OR_ANY = all,any#
*/

static void base_@TYPE@_@ALL_OR_ANY@_@OPNAME@
        (char **args, npy_intp *dimensions,
         npy_intp* steps, void* data)
{
    npy_intp i, n;
    npy_intp N = dimensions[0], I = dimensions[1];
    char *a_n = args[0], *b_n = args[1], *c_n = args[2];
    npy_intp a_N = steps[0], b_N = steps[1], c_N = steps[2];
    npy_intp a_I = steps[3], b_I = steps[4];

    char *a_i, *b_i;
    npy_@TYPE@ a, b;

    for (n = 0; n < N; n++) {
        a_i = a_n;
        b_i = b_n;

        @ALL_OR_ANY@_INNER_LOOP(@OP_PREFIX@@OP@, npy_@TYPE@)

        a_n += a_N;
        b_n += b_N;
        c_n += c_N;
    }
}

/**end repeat2**/
/**end repeat1**/
/**end repeat**/


/* -------------------------------------------------------------------------- */
/* vectorized versions*/

#define BLOCK_SIZE 1024
#define ALIGNMENT_SIZE 32
#define ALIGNED(p) ((unsigned long)p & ALIGNMENT_SIZE)

/*
*  The core array must be contiguous, ie the core dimension steps must
*  be equal to the sizeof the type
*
*  TODO: all contiguous signed and unsigned integer types could be handled by
*  a single vectorized all_equal function.  Besides there should be at least 
*  one simple C function without src templating.
*/
/**begin repeat
* #TYPE = float,double,int#
**/
void simd_core_contiguous_@TYPE@_all_equal(
    char **args, npy_intp *dimensions, npy_intp* steps, void* data)
{
    npy_intp i, n, j;
    npy_intp N = dimensions[0], I = dimensions[1];
    char *a_n = args[0], *b_n = args[1], *c_n = args[2];
    npy_intp a_N = steps[0], b_N = steps[1], c_N = steps[2];

    unsigned int true_count;
    @TYPE@ *x, *y;

    for (n = 0; n < N; n++) {
        *((npy_bool *)c_n) = NPY_TRUE;
        x = (@TYPE@ *)a_n;
        y = (@TYPE@ *)b_n;

        // get x aligned, helps compiler vectorize.  y can use unaligned
        // loads. do while so at least the first element is checked
        // before checking an entire chunk
        i = 0;
        do {
            if ((*x) == (*y)) {
                x++;
                y++;
                i++;
            } else {
                *((npy_bool *)c_n) = NPY_FALSE;
                i = I;
            }
        } while (!ALIGNED(x) & (i<I));

        // main loop in chunks with auto vectorize simd instructions
        for ( ; i<(I-BLOCK_SIZE) ; i+=BLOCK_SIZE) {
            true_count = 0;
            for (j=0 ; j<BLOCK_SIZE ; j++){
                true_count += ((*x) == (*y));
                x++;
                y++;
            }
            if (true_count != BLOCK_SIZE) {
                *((npy_bool *)c_n) = NPY_FALSE;
                i = I;
                break;
            }
        };

        // check remaining elements
        for ( ; i<I ; i++) {
            if ((*x) == (*y)) {
                x++;
                y++;
            } else {
                *((npy_bool *)c_n) = NPY_FALSE;
                break;
            } 
        }

        a_n += a_N;
        b_n += b_N;
        c_n += c_N;
    }
}
/**end repeat**/

/* -------------------------------------------------------------------------- */
/* dispatchers to select optimal function */

/**begin repeat
* #TYPE = byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,
*         double,longdouble,cfloat,cdouble,clongdouble#
* #IS_VECTD = 0*4,1,0*5,1,1,0*4#
*/
void dispatch_@TYPE@_all_equal(
    char **args, npy_intp *dimensions, npy_intp* steps, void* data)
{

    #if @IS_VECTD@
        npy_intp I = dimensions[1];
        npy_intp a_I = steps[3], b_I = steps[4];
        if ((I > (2*BLOCK_SIZE)) & (a_I == sizeof(@TYPE@)) 
                & (b_I == sizeof(@TYPE@)))
        {
            simd_core_contiguous_@TYPE@_all_equal(args, dimensions, steps, data);
            return;
        }
    #endif
    
    base_@TYPE@_all_equal(args, dimensions, steps, data);

}
/**end repeat**/


/* -------------------------------------------------------------------------- */
/* Create type arrays for each gufunc, which are all identical*/
static char types[] = {NPY_BYTE, NPY_BYTE, NPY_BOOL,
                       NPY_UBYTE, NPY_UBYTE, NPY_BOOL,
                       NPY_SHORT, NPY_SHORT, NPY_BOOL,
                       NPY_USHORT, NPY_USHORT, NPY_BOOL,

                       NPY_INT, NPY_INT, NPY_BOOL,
                       NPY_UINT, NPY_UINT, NPY_BOOL,
                       NPY_LONG, NPY_LONG, NPY_BOOL,
                       NPY_ULONG, NPY_ULONG, NPY_BOOL,

                       NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL,
                       NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL,
                       NPY_FLOAT, NPY_FLOAT, NPY_BOOL,
                       NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL,

                       NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL,
                       NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL,
                       NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL,
                       NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL};


/* -------------------------------------------------------------------------- */
/* create array of nulls for "data" for each gufunc type*/

static void *array_of_nulls[] = {
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL
};


/* -------------------------------------------------------------------------- */
/* define docstrings*/

static char const * const all_equal_doc =
    "Return True if x1 == x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1==x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "equal, all, any_equal, all_not_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.all_equal([[1, 2], [0, 0], [1, 2]], [1, 2])\n"
    "array([ True, False,  True], dtype=bool)";

static char const * const all_not_equal_doc =
    "Return True if x1 != x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1!=x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "not_equal, all, any_not_equal, all_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_not_equal(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.all_not_equal([[1, 2], [0, 0], [1, 2]], [1, 2])\n"
    "array([ False, True,  False], dtype=bool)";

static char const * const all_less_doc =
    "Return True if x1 < x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1<x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less, all, any_less, all_greater\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_less(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.all_less([[1, 2], [0, 0], [1, 2]], [1, 2])\n"
    "array([ False, True,  False], dtype=bool)";

static char const * const all_less_equal_doc =
    "Return True if x1 <= x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1<=x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less_equal, all, any_less_equal, all_greater_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_less_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.all_less_equal([[1, 2], [0, 0], [1, 3]], [1, 2])\n"
    "array([ True, True,  False], dtype=bool)";

static char const * const all_greater_doc =
    "Return True if x1 > x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1>x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater, all, any_less_equal, all_less_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_greater(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.all_greater([[1, 2], [0, 0], [1, 3]], [1, 2])\n"
    "array([ False, False,  False], dtype=bool)";

static char const * const all_greater_equal_doc =
    "Return True if x1 >= x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1<=x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater_equal, all, any_greater, all_less\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_greater_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.all_greater_equal([[1, 2], [0, 0], [2, 3]], [1, 2])\n"
    "array([ True, False,  True], dtype=bool)";

static char const * const any_equal_doc =
    "Return True if x1 == x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1==x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "equal, any, all_equal, any_not_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.any_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, False,  True], dtype=bool)";

static char const * const any_not_equal_doc =
    "Return True if x1 != x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1!=x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "not_equal, any, all_not_equal, any_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_not_equal(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.any_not_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, True,  True], dtype=bool)";

static char const * const any_less_doc =
    "Return True if x1 < x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1<x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less, any, all_less, any_greater_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_less(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.any_less([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, True,  False], dtype=bool)";

static char const * const any_less_equal_doc =
    "Return True if x1 <= x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1<=x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less_equal, any, all_less_equal, any_greater\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_less_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.any_less_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, True,  True], dtype=bool)";

static char const * const any_greater_doc =
    "Return True if x1 > x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1>x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater, any, all_greater, any_less_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_greater(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.any_greater([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ False, False,  True], dtype=bool)";

static char const * const any_greater_equal_doc =
    "Return True if x1 >= x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1>=x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater_equal, any, all_greater_equal, any_less\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_greater_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.any_greater_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, False,  True], dtype=bool)";


/* -------------------------------------------------------------------------- */
/* function to create and register all gufuncs*/

void InitLogicalGufuncs(PyObject *dictionary, 
                        PyUFunc_FromFuncAndDataAndSignature_t createPyUFunc) {
    PyObject *f;

/**begin repeat
* #NAME = all_equal,all_not_equal,all_less,all_less_equal,all_greater,all_greater_equal,
*         any_equal,any_not_equal,any_less,any_less_equal,any_greater,any_greater_equal#
* #APPROACH = dispatch,base*11#
*/

    static PyUFuncGenericFunction @NAME@_funcs[] = { 

/**begin repeat1
* #TYPE = byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,
*         double,longdouble,cfloat,cdouble,clongdouble#
*/

        @APPROACH@_@TYPE@_@NAME@,

/**end repeat1**/

    }; // close array of funcs



    f = createPyUFunc(@NAME@_funcs,
                      array_of_nulls,
                      types,
                      sizeof(types),  // number of types
                      2,              // number of inputs
                      1,              // number of outputs
                      PyUFunc_None,
                      "@NAME@",
                      (char*) @NAME@_doc,
                      0,              // unused
                      "(i),(i)->()");

    PyDict_SetItemString(dictionary, "@NAME@", f);
    Py_DECREF(f);

/**end repeat**/


}
