#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "Python.h"
#include "math.h"
#include "numpy/ndarraytypes.h"
#include "numpy/ufuncobject.h"
#include "numpy/npy_3kcompat.h"
#include "logical_gufuncs.h"
#include "lowlevel_strided_loops.h"


// define the basic real version similar to the macro for complex numbers
#define REQ(a,b) (a==b)
#define RNE(a,b) (a!=b)
#define RLT(a,b) (a<b)
#define RLE(a,b) (a<=b)
#define RGT(a,b) (a>b)
#define RGE(a,b) (a>=b)

/* -------------------------------------------------------------------------- */
/* create the family of functions using a template  */

#define BLOCK_SIZE 1024

/**begin repeat
* #TYPE = npy_byte,npy_ubyte,npy_short,npy_ushort,npy_int,npy_uint,npy_long,
*         npy_ulong,npy_longlong,npy_ulonglong,npy_float,npy_double,
*         npy_longdouble,npy_cfloat,npy_cdouble,npy_clongdouble#
* #OP_PREFIX = R,R,R,R,R,R,R,R,R,R,R,R,R,PyArray_C,PyArray_C,PyArray_C#
*/

/**begin repeat1
* #OP = EQ,NE,LT,LE,GT,GE#
* #OPNAME = equal,not_equal,less,less_equal,greater,greater_equal#
*/

/**begin repeat2
* #fname = all,any#
* #ALL_OR_ANY = NPY_TRUE,NPY_FALSE#
* #INV = ,!#
*/

/**begin repeat3
 * #isa = , _avx#
 * #ISA = , AVX#
 * #CHK = 1, HAVE_ATTRIBUTE_TARGET_AVX#
 * #ATTR = , NPY_GCC_TARGET_AVX#
 */

#if @CHK@
static NPY_GCC_OPT_3 @ATTR@ void base_@TYPE@_@fname@_@OPNAME@@isa@
        (char **args, npy_intp *dimensions,
         npy_intp* steps, void* data)
{
    npy_intp i, n;
    npy_intp N = dimensions[0], I = dimensions[1];
    char *a_n = args[0], *b_n = args[1], *c_n = args[2];
    npy_intp a_N = steps[0], b_N = steps[1], c_N = steps[2];
    npy_intp a_I = steps[3], b_I = steps[4];

    char *a_i, *b_i;

    for (n = 0; n < N; n++) {
        a_i = a_n;
        b_i = b_n;

        *((npy_bool *)c_n) = @ALL_OR_ANY@;

        i = 0;
        /* main loop in chunks with auto vectorize simd instructions */
        if (a_I == sizeof(@TYPE@) && b_I == sizeof(@TYPE@)) {
            for (i=0; i < npy_blocked_end(0, 1, BLOCK_SIZE, I);
                 i+=BLOCK_SIZE) {
                unsigned int true_count = 0, j;
                for (j=0 ; j<BLOCK_SIZE ; j++){
                    @TYPE@ a = *(@TYPE@ *)a_i;
                    @TYPE@ b = *(@TYPE@ *)b_i;
                    true_count += @INV@@OP_PREFIX@@OP@(a, b);
                    a_i += a_I;
                    b_i += b_I;
                }
                if (true_count != BLOCK_SIZE) {
                    *((npy_bool *)c_n) = !@ALL_OR_ANY@;
                    i = I;
                    break;
                }
            }
        }

        // check remaining elements
        for ( ; i<I ; i++) {
            if (@INV@@OP_PREFIX@@OP@(*(@TYPE@ *)a_i, *(@TYPE@ *)b_i)) {
                a_i += a_I;
                b_i += b_I;
            } else {
                *((npy_bool *)c_n) = !@ALL_OR_ANY@;
                break;
            } 
        }

        a_n += a_N;
        b_n += b_N;
        c_n += c_N;
    }
}
#endif

/**end repeat3**/
/**end repeat2**/
/**end repeat1**/
/**end repeat**/

/* -------------------------------------------------------------------------- */
/* Create type arrays for each gufunc, which are all identical*/
static char types[] = {NPY_BYTE, NPY_BYTE, NPY_BOOL,
                       NPY_UBYTE, NPY_UBYTE, NPY_BOOL,
                       NPY_SHORT, NPY_SHORT, NPY_BOOL,
                       NPY_USHORT, NPY_USHORT, NPY_BOOL,

                       NPY_INT, NPY_INT, NPY_BOOL,
                       NPY_UINT, NPY_UINT, NPY_BOOL,
                       NPY_LONG, NPY_LONG, NPY_BOOL,
                       NPY_ULONG, NPY_ULONG, NPY_BOOL,

                       NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL,
                       NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL,
                       NPY_FLOAT, NPY_FLOAT, NPY_BOOL,
                       NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL,

                       NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL,
                       NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL,
                       NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL,
                       NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL};


/* -------------------------------------------------------------------------- */
/* create array of nulls for "data" for each gufunc type*/

static void *array_of_nulls[] = {
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
    (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL
};


/* -------------------------------------------------------------------------- */
/* define docstrings*/

static char const * const all_equal_doc =
    "Return True if x1 == x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1==x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "equal, all, any_equal, all_not_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.all_equal([[1, 2], [0, 0], [1, 2]], [1, 2])\n"
    "array([ True, False,  True], dtype=bool)";

static char const * const all_not_equal_doc =
    "Return True if x1 != x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1!=x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "not_equal, all, any_not_equal, all_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_not_equal(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.all_not_equal([[1, 2], [0, 0], [1, 2]], [1, 2])\n"
    "array([ False, True,  False], dtype=bool)";

static char const * const all_less_doc =
    "Return True if x1 < x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1<x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less, all, any_less, all_greater\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_less(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.all_less([[1, 2], [0, 0], [1, 2]], [1, 2])\n"
    "array([ False, True,  False], dtype=bool)";

static char const * const all_less_equal_doc =
    "Return True if x1 <= x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1<=x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less_equal, all, any_less_equal, all_greater_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_less_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.all_less_equal([[1, 2], [0, 0], [1, 3]], [1, 2])\n"
    "array([ True, True,  False], dtype=bool)";

static char const * const all_greater_doc =
    "Return True if x1 > x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1>x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater, all, any_less_equal, all_less_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_greater(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.all_greater([[1, 2], [0, 0], [1, 3]], [1, 2])\n"
    "array([ False, False,  False], dtype=bool)";

static char const * const all_greater_equal_doc =
    "Return True if x1 >= x2 for all elements along the last axis, False\n"
    "otherwise.  Similar to (x1<=x2).all(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater_equal, all, any_greater, all_less\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.all_greater_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.all_greater_equal([[1, 2], [0, 0], [2, 3]], [1, 2])\n"
    "array([ True, False,  True], dtype=bool)";

static char const * const any_equal_doc =
    "Return True if x1 == x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1==x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "equal, any, all_equal, any_not_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.any_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, False,  True], dtype=bool)";

static char const * const any_not_equal_doc =
    "Return True if x1 != x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1!=x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "not_equal, any, all_not_equal, any_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_not_equal(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.any_not_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, True,  True], dtype=bool)";

static char const * const any_less_doc =
    "Return True if x1 < x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1<x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less, any, all_less, any_greater_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_less(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.any_less([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, True,  False], dtype=bool)";

static char const * const any_less_equal_doc =
    "Return True if x1 <= x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1<=x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "less_equal, any, all_less_equal, any_greater\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_less_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.any_less_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, True,  True], dtype=bool)";

static char const * const any_greater_doc =
    "Return True if x1 > x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1>x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater, any, all_greater, any_less_equal\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_greater(np.arange(3), np.arange(3))\n"
    "False\n"
    ">>> np.any_greater([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ False, False,  True], dtype=bool)";

static char const * const any_greater_equal_doc =
    "Return True if x1 >= x2 for any elements along the last axis, False\n"
    "otherwise.  Similar to (x1>=x2).any(axis=-1), except the last dimension\n"
    "of x1 and x2 must be equal and greater than 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x1, x2 : array_like\n"
    "    Input arrays of the same shape.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray or bool\n"
    "   Output array of bools, or a single bool if x1 and x2 are 1D.\n"
    "\n"
    "See Also\n"
    "-------\n"
    "greater_equal, any, all_greater_equal, any_less\n"
    "\n"
    "Examples\n"
    "-------\n"
    ">>> np.any_greater_equal(np.arange(3), np.arange(3))\n"
    "True\n"
    ">>> np.any_greater_equal([[1, 2], [0, 0], [2, 3]], [1, 3])\n"
    "array([ True, False,  True], dtype=bool)";


/* -------------------------------------------------------------------------- */
/* function to create and register all gufuncs*/

void InitLogicalGufuncs(PyObject *dictionary, 
                        PyUFunc_FromFuncAndDataAndSignature_t createPyUFunc) {
    PyObject *f;

/**begin repeat
* #NAME = all_equal,all_not_equal,all_less,all_less_equal,all_greater,
          all_greater_equal,any_equal,any_not_equal,any_less,any_less_equal,
          any_greater,any_greater_equal#
*/

    { // open bracket surrounding inner repeat

        static PyUFuncGenericFunction @NAME@_funcs_base[] = {

/**begin repeat1
* #TYPE = npy_byte,npy_ubyte,npy_short,npy_ushort,npy_int,npy_uint,npy_long,
*         npy_ulong,npy_longlong,npy_ulonglong,npy_float,npy_double,
*         npy_longdouble,npy_cfloat,npy_cdouble,npy_clongdouble#
*/

            base_@TYPE@_@NAME@,

/**end repeat1**/

        }; // close array of funcs
        static PyUFuncGenericFunction @NAME@_funcs_avx[] = {

/**begin repeat1
* #TYPE = npy_byte,npy_ubyte,npy_short,npy_ushort,npy_int,npy_uint,npy_long,
*         npy_ulong,npy_longlong,npy_ulonglong,npy_float,npy_double,
*         npy_longdouble,npy_cfloat,npy_cdouble,npy_clongdouble#
*/

            base_@TYPE@_@NAME@_avx,

/**end repeat1**/

        }; // close array of funcs

        PyUFuncGenericFunction * funcs = @NAME@_funcs_base;

#ifdef HAVE_ATTRIBUTE_TARGET_AVX
        if (NPY_CPU_SUPPORTS_AVX) {
            funcs = @NAME@_funcs_avx;
        }
#endif
        f = createPyUFunc(funcs,
                          array_of_nulls,
                          types,
                          sizeof(types),  // number of types
                          2,              // number of inputs
                          1,              // number of outputs
                          PyUFunc_None,
                          "@NAME@",
                          (char*) @NAME@_doc,
                          0,              // unused
                          "(i),(i)->()");

        PyDict_SetItemString(dictionary, "@NAME@", f);
        Py_DECREF(f);

    }; // close bracket surrounding inner repeat

/**end repeat**/

}
